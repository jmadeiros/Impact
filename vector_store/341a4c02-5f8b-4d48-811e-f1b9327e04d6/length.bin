else:
            lm_logits = self.lm_head(sequence_output)

        if not return_dict:
            return (lm_logits,) + decoder_outputs[1:] + encoder_outputs

        return FlaxSeq2SeqLMOutput(
            logits=lm_logits,
            past_key_values=decoder_outputs.past_key_values,
            decoder_hidden_states=decoder_outputs.hidden_states,
            decoder_attentions=decoder_outputs.attentions,
            cross_attentions=decoder_outputs.cross_attentions,
            encoder_last_hidden_state=encoder_outputs.last_hidden_state,
            encoder_hidden_states=encoder_outputs.hidden_states,
            encoder_attentions=encoder_outputs.attentions,
        )


class FlaxT5ForConditionalGeneration(FlaxT5PreTrainedModel):
    module_class = FlaxT5ForConditionalGenerationModule

    @add_start_docstrings(T5_DECODE_INPUTS_DOCSTRING)
    @replace_return_docstrings(output_type=FlaxCausalLMOutputWithCrossAttentions, config_class=T5Config)
    def decode(
        self,
        decoder_input_ids,
        encoder_outputs,
        encoder_attention_mask: Optional[jnp.ndarray] = None,
        decoder_attention_mask: Optional[jnp.ndarray] = None,
        past_key_values: Optional[dict] = None,
        output_attentions: Optional[bool] = None,
        output_hidden_states: Optional[bool] = None,
        return_dict: Optional[bool] = None,
        train: bool = False,
        params: Optional[dict] = None,
        dropout_rng: PRNGKey = None,
    ):
        r"""
        Returns:

        Example:

        ```python
        >>> from transformers import AutoTokenizer, FlaxT5ForConditionalGeneration
        >>> import jax.numpy as jnp

        >>> tokenizer = AutoTokenizer.from_pretrained("google-t5/t5-small")
        >>> model = FlaxT5ForConditionalGeneration.from_pretrained("google-t5/t5-small")

        >>> text = "summarize: My friends are cool but they eat too many carbs."
        >>> inputs = tokenizer(text, return_tensors="np")
        >>> encoder_outputs = model.encode(**inputs)

        >>> decoder_start_token_id = model.config.decoder_start_token_id
        >>> decoder_input_ids = jnp.ones((inputs.input_ids.shape[0], 1), dtype="i4") * decoder_start_token_id

        >>> outputs = model.decode(decoder_input_ids, encoder_outputs)
        >>> logits = outputs.logits
        ```"""
        output_attentions = output_attentions if output_attentions is not None else self.config.output_attentions
        output_hidden_states = (
            output_hidden_states if output_hidden_states is not None else self.config.output_hidden_states
        )
        return_dict = return_dict if return_dict is not None else self.config.return_dict

        encoder_hidden_states = encoder_outputs[0]
        if encoder_attention_mask is None:
            batch_size, sequence_length = encoder_hidden_states.shape[:2]
            encoder_attention_mask = jnp.ones((batch_size, sequence_length))

        batch_size, sequence_length = decoder_input_ids.shape
        if decoder_attention_mask is None:
            decoder_attention_mask = jnp.ones((batch_size, sequence_length))

        # Handle any PRNG if needed
        rngs = {}
        if dropout_rng is not None:
            rngs["dropout"] = dropout_rng

        inputs = {"params": params or self.params}

        # if past_key_values are passed then cache is already initialized a private flag init_cache has to be
        # passed down to ensure cache is used. It has to be made sure that cache is marked as mutable so that
        # it can be changed by FlaxT5Attention module
        if past_key_values:
            inputs["cache"] = past_key_values
            mutable = ["cache"]
        else:
            mutable = False

        def _decoder_forward(module, decoder_input_ids, decoder_attention_mask, **kwargs):
            decoder_module = module._get_decoder_module()
            decoder_outputs = decoder_module(
                decoder_input_ids,
                decoder_attention_mask,
                **kwargs,
            )

            sequence_output = decoder_outputs[0]

            if self.config.tie_word_embeddings:
                # Rescale output before projecting on vocab
                # See https://github.com/tensorflow/mesh/blob/fa19d69eafc9a482aff0b59ddd96b025c0cb207d/mesh_tensorflow/transformer/transformer.py#L586
                sequence_output = sequence_output * (self.config.d_model**-0.5)

            if self.config.tie_word_embeddings:
                shared_embedding = module.shared.variables["params"]["embedding"]
                lm_logits = module.lm_head.apply({"params": {"kernel": shared_embedding.T}}, sequence_output)
            else:
                lm_logits = module.lm_head(sequence_output)

            return lm_logits, decoder_outputs

        outputs = self.module.apply(
            inputs,
            decoder_input_ids=jnp.array(decoder_input_ids, dtype="i4"),
            decoder_attention_mask=jnp.array(decoder_attention_mask, dtype="i4"),
            encoder_hidden_states=encoder_hidden_states,
            encoder_attention_mask=jnp.array(encoder_attention_mask, dtype="i4"),
            output_attentions=output_attentions,
            output_hidden_states=output_hidden_states,
            return_dict=return_dict,
            deterministic=not train,
            rngs=rngs,
            mutable=mutable,
            method=_decoder_forward,
        )

        if past_key_values is None:
            lm_logits, decoder_outputs = outputs
        else:
            (lm_logits, decoder_outputs), past = outputs

        if return_dict:
            outputs = FlaxCausalLMOutputWithCrossAttentions(
                logits=lm_logits,
                hidden_states=decoder_outputs.hidden_states,
                attentions=decoder_outputs.attentions,
                cross_attentions=decoder_outputs.cross_attentions,
            )
        else:
            outputs = (lm_logits,) + decoder_outputs[1:]

        # add updated cache to model output
        if past_key_values is not None and return_dict:
            outputs["past_key_values"] = unfreeze(past["cache"])
            return outputs
        elif past_key_values is not None and not return_dict:
            outputs = outputs[:1] + (unfreeze(past["cache"]),) + outputs[1:]

        return outputs

    def prepare_inputs_for_generation(
        self,
        decoder_input_ids,
        max_length,
        attention_mask: Optional[jax.Array] = None,
        decoder_attention_mask: Optional[jax.Array] = None,
        encoder_outputs=None,
        **kwargs,
    ):
        # initializing the cache
        batch_size, seq_length = decoder_input_ids.shape

        past_key_values = self.init_cache(batch_size, max_length, encoder_outputs)
        # Note that usually one would have to put 0's in the attention_mask for x > input_ids.shape[-1] and x < cache_length.
        # But since the decoder uses a causal mask, those positions are masked anyways.
        # Thus we can create a single static attention_mask here, which is more efficient for compilation
        extended_attention_mask = jnp.ones((batch_size, max_length), dtype="i4")
        if decoder_attention_mask is not None:
            extended_attention_mask = jax.lax.dynamic_update_slice(
                extended_attention_mask, decoder_attention_mask, (0, 0)
            )

        return {
            "past_key_values": past_key_values,
            "encoder_outputs": encoder_outputs,
            "encoder_attention_mask": attention_mask,
            "decoder_attention_mask": extended_attention_mask,
        }

    def update_inputs_for_generation(self, model_outputs, model_kwargs):
        model_kwargs["past_key_values"] = model_outputs.past_key_values
        return model_kwargs


FLAX_T5_CONDITIONAL_GENERATION_DOCSTRING = """
    Returns:

    Example:

    ```python
    >>> from transformers import AutoTokenizer, FlaxT5ForConditionalGeneration

    >>> tokenizer = AutoTokenizer.from_pretrained("google-t5/t5-small")
    >>> model = FlaxT5ForConditionalGeneration.from_pretrained("google-t5/t5-small")

    >>> ARTICLE_TO_SUMMARIZE = "summarize: My friends are cool but they eat too many carbs."
    >>> inputs = tokenizer([ARTICLE_TO_SUMMARIZE], return_tensors="np")

    >>> # Generate Summary
    >>> summary_ids = model.generate(inputs["input_ids"]).sequences
    >>> print(tokenizer.decode(summary_ids[0], skip_special_tokens=True, clean_up_tokenization_spaces=False))
    ```
"""


overwrite_call_docstring(
    FlaxT5ForConditionalGeneration, T5_INPUTS_DOCSTRING + FLAX_T5_CONDITIONAL_GENERATION_DOCSTRING
)
append_replace_return_docstrings(
    FlaxT5ForConditionalGeneration, output_type=FlaxSeq2SeqLMOutput, config_class=_CONFIG_FOR_DOC
)


__all__ = ["FlaxT5EncoderModel", "FlaxT5ForConditionalGeneration", "FlaxT5Model", "FlaxT5PreTrainedModel"]
 )r∂  r™   r´   r≈   r^  s        rD   rT  zTarFile.taropenY  s-   Ä  –+—+‹–@”A–AŸê4òòw—1®&—1–1rF   c                 Ûé  ó |dvrt        d´      Ç	 ddlm} 	  |||dz   ||´      }	  | j                  |||fi |§é}d
|_	        |S # t        $ r t	        d´      dÇw xY w# t
        $ r}|Å|dk(  rt        d	´      |ÇÇ d}~ww xY w# t
        $ r'}|j                  ´        |dk(  rt        d	´      |ÇÇ d}~w |j                  ´        Ç xY w)zkOpen gzip compressed tar archive name for reading or writing.
           Appending is not allowed.
        ©rü   r†   r  ˙mode must be 'r', 'w' or 'x'r   )⁄GzipFilezgzip module is not availableNr|   rü   rÒ   F)
r<   ⁄gzipri  r…   r	   r“   r   rT  rØ   r¡   )	r∂  r™   r´   r≈   rÿ   r^  ri  r  r  s	            rD   ⁄gzopenzTarFile.gzopena  sÛ   Ä 
 ê—&‹–;”<–<	M›%	Ÿòt†T®C°Z∞¿”HàG		ÿêóëòD†$®—:∞6—:àA àåÿà¯Ù+ Ú 	M‹"–#A”B»–L	M˚Ù
 Ú 	ÿ–"†t®s¢{‹– 1”2∏–9ÿ˚	˚Ù Ú 	ÿèMâMåOÿêsä{‹– 1”2∏–9ÿ˚	ÿèMâMåOÿ˙s9   ëA òA ßB ¡A¡	B ¡'A;¡;B ¬	C¬"B.¬.Cc                 ÛP  ó |dvrt        d´      Ç	 ddlm}  ||xs |||¨´      }	  | j
                  |||fi |§é}d
|_
        |S # t        $ r t	        d´      dÇw xY w# t        t        f$ r'}|j                  ´        |dk(  rt        d	´      |ÇÇ d}~w |j                  ´        Ç xY w)zlOpen bzip2 compressed tar archive name for reading or writing.
           Appending is not allowed.
        rg  rh  r   )⁄BZ2Filerº   N)rÿ   rü   znot a bzip2 fileF)r<   rª   rm  r…   r	   rT  r“   ⁄EOFErrorrØ   r   r¡   )	r∂  r™   r´   r≈   rÿ   r^  rm  r  r  s	            rD   ⁄bz2openzTarFile.bz2openÇ  s≈   Ä 
 ê—&‹–;”<–<	L›#Ò ò'ö/†T®4∏}‘Mà		ÿêóëòD†$®—:∞6—:àA àåÿà¯Ù! Ú 	L‹"–#@”A¿t–K	L˚Ù ú–"Ú 	ÿèMâMåOÿêsä{‹– 2”3∏–:ÿ˚	ÿèMâMåOÿ˙s"   ëA ßA ¡A¡B%¡-"B¬B%c                 ÛL  ó |dvrt        d´      Ç	 ddlm}m}  ||xs |||¨´      }	  | j                  |||fi |§é}d
|_
        |S # t        $ r t        d´      dÇw xY w# |t        f$ r'}	|j                  ´        |dk(  rt        d	´      |	ÇÇ d}	~	w |j                  ´        Ç xY w)zkOpen lzma compressed tar archive name for reading or writing.
           Appending is not allowed.
        rg  rh  r   )⁄LZMAFiler÷   ræ   N)⁄presetrü   znot an lzma fileF)r<   r‘   rq  r÷   r…   r	   rT  rn  rØ   r   r¡   )
r∂  r™   r´   r≈   rr  r^  rq  r÷   r  r  s
             rD   ⁄xzopenzTarFile.xzopenû  s≈   Ä 
 ê—&‹–;”<–<	Mﬂ0Ò ò7ö?†d®D∏‘@à		ÿêóëòD†$®—:∞6—:àA àåÿà¯Ù! Ú 	M‹"–#A”B»–L	M˚ ú8–$Ú 	ÿèMâMåOÿêsä{‹– 2”3∏–:ÿ˚	ÿèMâMåOÿ˙s"   ëA ©A  ¡A¡ B#¡+"B¬B#rT  rk  ro  rs  )rø   r∫   rª   rΩ   c                 Û  ó | j                   ryd| _         	 | j                  dv rê| j                  j                  t        t
        dz  z  ´       | xj                  t
        dz  z  c_        t        | j                  t        ´      \  }}|dkD  r)| j                  j                  t        t        |z
  z  ´       | j                  s| j                  j                  ´        yy# | j                  s| j                  j                  ´        w w xY w)zlClose the TarFile. In write-mode, two finishing zero blocks are
           appended to the archive.
        NTrB  r.   r   )r«   r´   r≈   ru   r?   r  r  rs   ⁄
RECORDSIZEr¡   rØ   )r©   rz   r{   s      rD   rØ   zTarFile.close≈  s    Ä  è;ä;ÿ‡àå	%ÿèyâyòO—+ÿóë◊"—"§3¨)∞a©-—#8‘9ÿóí§	®A°—.ïÙ %+®4Ø;©;º
”$C—!êò	ÿòqí=ÿóLëL◊&—&§s¨j∏9—.D—'E‘F‡◊#“#ÿóë◊"—"’$ $¯ê4◊#“#ÿóë◊"—"’$ $˙s   ñBC √)Dc                 Ûf   ó | j                  |j                  d´      ´      }|Ät        d|z  ´      Ç|S )a  Return a TarInfo object for member `name'. If `name' can not be
           found in the archive, KeyError is raised. If a member occurs more
           than once in the archive, its last occurrence is assumed to be the
           most up-to-date version.
        rW  zfilename %r not found)⁄
_getmemberr‹  ⁄KeyError)r©   r™   r>  s      rD   ⁄	getmemberzTarFile.getmember⁄  s6   Ä  ó/ë/†$ß+°+®c”"2”3àÿà?‹–2∞T—9”:–:ÿàrF   c                 Ûr   ó | j                  ´        | j                  s| j                  ´        | j                  S )zéReturn the members of the archive as a list of TarInfo objects. The
           list has the same order as the members in the archive.
        )⁄_checkrM  ⁄_loadrL  r∞   s    rD   ⁄
getmemberszTarFile.getmembersÂ  s'   Ä  	èâåÿè|ä|ÿèJâJåL‡è|â|–rF   c                 Û\   ó | j                  ´       D ècg c]  }|j                  ëå c}S c c}w )zãReturn the members of the archive as a list of their names. It has
           the same order as the list returned by getmembers().
        )r}  r™   )r©   r>  s     rD   ⁄getnameszTarFile.getnamesÔ  s)   Ä  -1ØO©O‘,=”>—,=†êóì–,=—>–>˘“>s   ì)c                 Û.  ó | j                  d´       |Å|j                  }|Ä|}t        j                  j	                  |´      \  }}|j                  t        j                  d´      }|j                  d´      }| j                  ´       }| |_	        |Ä8| j                  st        j                  |´      }n9t        j                  |´      }n#t        j                  |j                  ´       ´      }d}|j                  }t        j                   |´      rÑ|j"                  |j$                  f}	| j                  sE|j&                  dkD  r6|	| j(                  v r(|| j(                  |	   k7  rt*        }
| j(                  |	   }nΩt,        }
|	d   r≤|| j(                  |	<   n¢t        j.                  |´      rt0        }
nÜt        j2                  |´      rt4        }
njt        j6                  |´      rt8        }
t        j:                  |´      }n9t        j<                  |´      rt>        }
nt        j@                  |´      rtB        }
ny||_        ||_"        |jF                  |_$        |jJ                  |_&        |
t,        k(  r|jN                  |_(        nd|_(        |jR                  |_*        |
|_+        ||_,        tZ        r(	 t[        j\                  |jH                  ´      d   |_/        tb        r(	 tc        jd                  |jL                  ´      d   |_3        |
t>        tB        fv rhti        t        d´      rXti        t        d´      rHt        jj                  |jl                  ´      |_7        t        jp                  |jl                  ´      |_9        |S # t`        $ r Y å±w xY w# t`        $ r Y åíw xY w)	a“  Create a TarInfo object from the result of os.stat or equivalent
           on an existing file. The file is either named by `name', or
           specified as a file object `fileobj' with a file descriptor. If
           given, `arcname' specifies an alternative name for the file in the
           archive, otherwise, the name is taken from the 'name' attribute of
           'fileobj', or the 'name' argument. The name should be a text
           string.
        ⁄awxNrW  rπ   r-   r   ⁄major⁄minor):r{  r™   r¢   r/   ⁄
splitdriverﬂ   r[  r\  r>  r=  rG  ⁄lstat⁄stat⁄fstat⁄fileno⁄st_mode⁄S_ISREG⁄st_ino⁄st_dev⁄st_nlinkrN  r(  r{  ⁄S_ISDIRrç  ⁄S_ISFIFOr.  ⁄S_ISLNKr&  ⁄readlink⁄S_ISCHRræ  ⁄S_ISBLKrø  r´   ⁄st_uidr3   ⁄st_gidr4   ⁄st_sizer1   ⁄st_mtimer2   rt  rc  ⁄pwd⁄getpwuidr5   rx  ⁄grp⁄getgrgidr6   rß   rÇ  ⁄st_rdevru  rÉ  rv  )r©   r™   ⁄arcnamer≈   ⁄drvr>  ⁄statresrc  ⁄stmd⁄inodert  s              rD   ⁄
gettarinfozTarFile.gettarinfoı  s∆  Ä  	èâêE‘ –ÿó<ë<àD
 à?ÿàG‹ówëw◊)—)®'”2âààWÿó/ë/§"ß&°&®#”.àÿó.ë.†”%à ó,ë,ì.àÿàå à?ÿ◊#“#‹ü(ô(†4õ.ë‰ü'ô'†$õ-ë‰óhëhòwü~ô~”/”0àGÿà‡èâà‹è<â<ò‘ÿó^ë^†Wß^°^–4àEÿ◊#“#®◊(8—(8∏1“(<ÿòTü[ô[—(®W∏øπ¿E—8J“-JÙ êÿü;ô;†u—-ëÙ êÿòí8ÿ)0êDóKëK†“&‹è\â\ò$‘‹âD‹è]â]ò4‘ ‹âD‹è\â\ò$‘‹àD‹ó{ë{†4”(âH‹è\â\ò$‘‹âD‹è\â\ò$‘‹âD‡ àåÿàåÿónënàåÿónënàåÿî7ä?ÿ"ü?ô?àGçL‡àGåLÿ◊(—(àåÿàåÿ#à‘›‹ #ß°®WØ[©[” 9∏!— <êîı ‹ #ß°®WØ[©[” 9∏!— <êî îGúW–%—%‹îrò7‘#¨¥∞G‘(<‹#%ß8°8®GØO©O”#<ê‘ ‹#%ß8°8®GØO©O”#<ê‘ ÿà¯Ù Ú Ÿ˚Ù
 Ú Ÿ˙s$    ,'M9 À'N Õ9	NŒNŒ	NŒN)rL  c                Ûú  ó | j                  ´        |Ä| }|D ê]≤  }|êr&|j                  Ät        d´       n(t        t        j                  |j                  ´      ´       t        |j
                  xs |j                  õd|j                  xs |j                  õù´       |j                  ´       s|j                  ´       r(t        dd|j                  |j                  fz  z  ´       nt        d|j                  z  ´       |j                  Ät        d´       n.t        dt        j                   |j                  ´      dd	 z  ´       t        |j"                  |j%                  ´       rdnd
z   ´       |rP|j'                  ´       rt        d|j(                  z   ´       |j+                  ´       rt        d|j(                  z   ´       t-        ´        êåµ y)a  Print a table of contents to sys.stdout. If `verbose' is False, only
           the names of the members are printed. If it is True, an `ls -l'-like
           output is produced. `members' is optional and must be a subset of the
           list returned by getmembers().
        Nz
??????????rW  z%10sz%d,%dz%10dz????-??-?? ??:??:??z%d-%02d-%02d %02d:%02d:%02drÛ   rπ   z-> zlink to )r{  r´   rÖ   rÜ  rc  r5   r3   r6   r4   r*  r,  ru  rv  r1   r2   rÂ   ⁄	localtimer™   ra  rb  rc  r`  rÑ   )r©   ⁄verboserL  r>  s       rD   r  zTarFile.listX  sf  Ä  	èâå‡à?ÿàG‹àG⁄ÿó<ë<–'‹†’-‰§ß°®gØl©l” ;‘<‹†wß}°}“'C∏øπ—'Cÿ'.ß}°}“'C∏øπ–'CEÙ F‡ó=ë=î?†gßm°m§o‹†ÿ$®◊(8—(8∏'◊:J—:J–'K—KÒ!Mı NÙ  †®Ø©— 5‘6ÿó=ë=–(‹– 5’6‰– =‹"&ß.°.∞∑±”"?¿¿–"CÒ!DÙ EÙ òüô®wØ}©}¨©¿B—G‘H·ÿó=ë=î?‹†®◊(8—(8— 8‘9ÿó=ë=î?‹†
®W◊-=—-=— =‘>‹éGÒ5 rF   ©⁄filterc                Ûb  ó | j                  d´       |Ä|}| j                  ÅBt        j                  j	                  |´      | j                  k(  r| j                  dd|z  ´       y| j                  d|´       | j                  ||´      }|Ä| j                  dd|z  ´       y|Å  ||´      }|Ä| j                  dd|z  ´       y|j                  ´       r(t        |d´      5 }| j                  ||´       ddd´       y|j                  ´       râ| j                  |´       |rut        t        j                  |´      ´      D ]S  }| j                  t        j                  j                  ||´      t        j                  j                  ||´      ||¨	´       åU yy| j                  |´       y# 1 sw Y   yxY w)
a!  Add the file `name' to the archive. `name' may be any type of file
           (directory, fifo, symbolic link, etc.). If given, `arcname'
           specifies an alternative name for the file in the archive.
           Directories are added recursively by default. This can be avoided by
           setting `recursive' to False. `filter' is a function
           that expects a TarInfo object argument and returns the changed
           TarInfo object, if it returns None the TarInfo object will be
           excluded from the archive.
        rÅ  Nr.   ztarfile: Skipped %rr-   ztarfile: Unsupported type %r˙tarfile: Excluded %rr<  r¶  )r{  r™   r¢   r/   rF  ⁄_dbgr¢  r_  rE  ⁄addfilera  r\  ⁄listdir⁄addr  )r©   r™   rù  ⁄	recursiverß  r>  ⁄fs          rD   r≠  zTarFile.add~  sq  Ä  	èâêE‘‡à?ÿàG è9â9– §RßW°Wß_°_∞T”%:∏døiπi“%GÿèIâIêa–.∞—5‘6ÿ‡è	â	ê!êT‘ ó/ë/†$®”0à‡à?ÿèIâIêa–7∏$—>‘?ÿ –ŸòWìoàGÿàÿó	ë	ò!–3∞d—:‘;ÿ è=â=å?‹ò4†‘&®!ÿóëòW†a‘(˜ '–& è]â]å_ÿèLâLò‘!Ÿ‹§ß
°
®4” 0÷1êAÿóHëHúRüWôWü\ô\®$∞”2¥B∑G±G∑L±L¿»!”4Lÿ%®f ı 6Ò 2  èLâLò’!˜ '–&˙s   √F%∆%F.c                 Ûî  ó | j                  d´       t        j                  |´      }|j                  | j                  | j                  | j
                  ´      }| j                  j                  |´       | xj                  t        |´      z  c_        | j                  }|Åèt        || j                  |j                  |¨´       t        |j                  t        ´      \  }}|dkD  r.| j                  j                  t        t        |z
  z  ´       |dz  }| xj                  |t        z  z  c_        | j                   j#                  |´       y)a  Add the TarInfo object `tarinfo' to the archive. If `fileobj' is
           given, it should be a binary file, and tarinfo.size bytes are read
           from it and added to the archive. You can create TarInfo objects
           directly, or by using gettarinfo().
        rÅ  N)ry   r   r-   )r{  rà  ró  rb   rB   rC   r≈   ru   r  r>   rK  rr   r1   rs   r  r?   rL  r  )r©   r>  r≈   rk   ry   rz   r{   s          rD   r´  zTarFile.addfile±  sÌ   Ä  	èâêE‘‰ó)ë)òG”$à‡èmâmòDüKôK®Ø©∏øπ”Dàÿèâ◊—ò3‘ÿèäîsò3ìx—çÿ◊ — à‡–‹ò†ß°®wØ|©|¿W’M‹ &†wß|°|¥Y” ?—àFêIÿò1ä}ÿóë◊"—"§3¨)∞i—*?—#@‘Aÿò!ëêÿèKäKò6§I—-—-çK‡èâ◊—òG’$rF   c                 Û  ó |ÄM| j                   }|Ä"t        j                  dt        d¨´       t        S t        |t        ´      rt        d´      Ç|S t        |´      r|S 	 t        |   S # t        $ r t        d|õdù´      d Çw xY w)NzòPython 3.14 will, by default, filter extracted tar archives and reject files or modify their metadata. Use the filter argument to control this behavior.r  )⁄
stacklevelzrString names are not supported for TarFile.extraction_filter. Use a function such as tarfile.data_filter directly.zfilter z
 not found)⁄extraction_filter⁄warnings⁄warn⁄DeprecationWarningr   r©  r¨  ⁄	TypeError⁄callable⁄_NAMED_FILTERSrx  r<   )r©   rß  s     rD   ⁄_get_filter_functionzTarFile._get_filter_function   s†   Ä ÿà>ÿ◊+—+àFÿà~‹óëJÙ '∞1ı	6Ù
 ,–+‹ò&§#‘&‹6Û7 7 àM‹êF‘ÿàM	G‹!†&—)–)¯‹Ú 	G‹òw†v†j∞
–;”<¿$–F	G˙s   ¡A' ¡'B)⁄numeric_ownerrß  c                Û@  ó g }| j                  |´      }|Ä| }|D ]]  }| j                  |||´      }|Äå|j                  ´       r|j                  |´       | j	                  |||j                  ´        |¨´       å_ |j                  dÑ d¨´       |D ]e  }t        j                  j                  ||j                  ´      }		 | j                  ||	|¨´       | j                  ||	´       | j                  ||	´       åg y# t        $ r}
| j                  |
´       Y d}
~
åàd}
~
ww xY w)aò  Extract all members from the archive to the current working
           directory and set owner, modification time and permissions on
           directories afterwards. `path' specifies a different directory
           to extract to. `members' is optional and must be a subset of the
           list returned by getmembers(). If `numeric_owner` is True, only
           the numbers for user/group names are used and not the names.

           The `filter` function will be called on each member just
           before extraction.
           It can return a changed TarInfo or None to skip the member.
           String names of common filters are accepted.
        N©⁄	set_attrsrª  c                 Û   ó | j                   S rÆ   r~  )r@  s    rD   ⁄<lambda>z$TarFile.extractall.<locals>.<lambda>	  s   Ä †qßv¢vrF   T)rW  ⁄reverse)rª  )r∫  ⁄_get_extract_tarinfora  r  ⁄_extract_one⁄sortr¢   r/   r  r™   ⁄chown⁄utime⁄chmodr   ⁄_handle_nonfatal_error)r©   r/   rL  rª  rß  ⁄directories⁄filter_functionre  r>  ⁄dirpathr  s              rD   ⁄
extractallzTarFile.extractall·  s  Ä  à‡◊3—3∞F”;àÿà?ÿàG„àFÿ◊/—/∞∏»”NàGÿàÿÿè}â}å ◊"—"†7‘+ÿ◊—òg†t∏7ø=π=ª?–7Jÿ,9 ı ;  	◊——-∞t–‘<Û #àG‹ógëgólël†4®Ø©”6àG/ÿó
ë
ò7†G∏=ê
‘Iÿó
ë
ò7†G‘,ÿó
ë
ò7†G’,Ò #¯Ù  Ú /ÿ◊+—+®A◊.—.˚/˙s   ¬>8C9√9	DƒDƒDc                Ûz   ó | j                  |´      }| j                  |||´      }|Å| j                  ||||´       yy)aØ  Extract a member from the archive to the current working directory,
           using its full name. Its file information is extracted as accurately
           as possible. `member' may be a filename or a TarInfo object. You can
           specify a different directory using `path'. File attributes (owner,
           mtime, mode) are set unless `set_attrs' is False. If `numeric_owner`
           is True, only the numbers for user/group names are used and not
           the names.

           The `filter` function will be called before extraction.
           It can return a changed TarInfo or None to skip the member.
           String names of common filters are accepted.
        N)r∫  r¬  r√  )r©   re  r/   ræ  rª  rß  r   r>  s           rD   ⁄extractzTarFile.extract	  sG   Ä  ◊3—3∞F”;àÿ◊+—+®F∞O¿T”Jàÿ–ÿ◊—òg†t®Y∏’F rF   c                 Û  ó t        |t        ´      r| j                  |´      }n|}|}	  |||´      }|Ä | j                  dd|j                  z  ´       y|j                  ´       rDt        j                  |´      }t        j                  j                  ||j                  ´      |_        |S # t        t        f$ r}| j                  |´       Y d}~åùd}~wt        $ r}| j                  |´       Y d}~åød}~ww xY w)z@Get filtered TarInfo (or None) from member, which might be a strNr.   r©  )r©  r¨  ry  r“   r   ⁄_handle_fatal_errorr   r»  r™  r™   r`  rà  r¢   r/   r  rc  ry  )r©   re  r   r/   r>  ⁄
unfilteredr  s          rD   r¬  zTarFile._get_extract_tarinfo!	  s“   Ä ‰êfúc‘"ÿónën†V”,âG‡àG‡à
	+Ÿ%†g®t”4àG
 à?ÿèIâIêa–/∞*∑/±/—A‘Bÿ‡è=â=å?‹óiëi†”(àG‹#%ß7°7ß<°<∞∞g◊6F—6F”#GàG‘ ÿà¯Ù ú–%Ú 	(ÿ◊$—$†Q◊'—'˚‹Ú 	+ÿ◊'—'®◊*—*˚	+˙s#   ®	B) ¬)C5¬8C√C5√C0√0C5c                 Û4  ó | j                  d´       	 | j                  |t        j                  j	                  ||j
                  ´      ||¨´       y# t        $ r}| j                  |´       Y d}~yd}~wt        $ r}| j                  |´       Y d}~yd}~ww xY w)z%Extract from filtered tarinfo to diskrü   rΩ  N)
r{  ⁄_extract_memberr¢   r/   r  r™   r“   r–  r   r»  )r©   r>  r/   ræ  rª  r  s         rD   r√  zTarFile._extract_one8	  sÄ   Ä ‡èâêC‘	+ÿ◊ — †¨"Ø'©'Ø,©,∞t∏Wø\π\”*Jÿ+4ÿ/< !ı >¯Ù Ú 	(ÿ◊$—$†Q◊'—'˚‹Ú 	+ÿ◊'—'®◊*—*˚	+˙s#   ì=A ¡	B¡A0¡0B¡<B¬Bc                 ÛN   ó | j                   dkD  rÇ | j                  dd|z  ´       y)z=Handle non-fatal error (ExtractError) according to errorlevelr-   ˙tarfile: %sN)rJ  r™  ©r©   r  s     rD   r»  zTarFile._handle_nonfatal_errorE	  s$   Ä ‡è?â?òQ“ÿ‡èIâIêaò®—*’+rF   c                 ÛL  ó | j                   dkD  rÇ t        |t        ´      rY|j                  Ä | j	                  dd|j
                  z  ´       y| j	                  dd|j
                  õd|j                  õù´       y| j	                  ddt        |´      j                  õd|õù´       y)z1Handle "fatal" error according to self.errorlevelr   Nr-   r’  z	tarfile: r   )rJ  r©  r“   ⁄filenamer™  ⁄strerrorrt  rà   r÷  s     rD   r–  zTarFile._handle_fatal_errorL	  st   Ä ‡è?â?òQ“ÿ‹òú7‘#ÿèzâz–!ÿó	ë	ò!ò]®QØZ©Z—7’8‡ó	ë	ô!∞∑≥∏QøZ∫Z–H’I‡èIâIëa¨T∞!´W◊-=”-=πq–A’BrF   c                 Û†  ó | j                  d´       t        |t        ´      r| j                  |´      }n|}|j	                  ´       s|j
                  t        vr| j                  | |´      S |j                  ´       s|j                  ´       rEt        | j                  t        ´      rt        d´      Ç| j                  | j                  |´      ´      S y)a\  Extract a member from the archive as a file object. `member' may be
           a filename or a TarInfo object. If `member' is a regular file or
           a link, an io.BufferedReader object is returned. For all other
           existing members, None is returned. If `member' does not appear
           in the archive, KeyError is raised.
        rü   z'cannot extract (sym)link as file objectN)r{  r©  r¨  ry  r_  rt  rÓ  ⁄
fileobjectr`  rb  r≈   r∂   r
   ⁄extractfile⁄_find_link_target)r©   re  r>  s      rD   r‹  zTarFile.extractfileX	  s¢   Ä  	èâêC‘‰êfúc‘"ÿónën†V”,âG‡àG‡è=â=å?ògülôl¥/—A‡ó?ë?†4®”1–1‡è]â]å_†ß°§‹ò$ü,ô,¨‘0Ù "–"K”L–L ◊'—'®◊(>—(>∏w”(G”H–H rF   c                 ÛÇ  ó |j                  d´      }|j                  dt        j                  ´      }t        j                  j                  |´      }|r4t        j                  j                  |´      st        j                  |´       |j                  ´       s|j                  ´       r,| j                  d|j                  õd|j                  õù´       n| j                  d|j                  ´       |j                  ´       r| j                  ||´       n„|j                  ´       r| j!                  ||´       n¿|j#                  ´       r| j%                  ||´       nù|j'                  ´       s|j)                  ´       r| j+                  ||´       nj|j                  ´       s|j                  ´       r| j-                  ||´       n7|j.                  t0        vr| j3                  ||´       n| j                  ||´       |rI| j5                  |||´       |j                  ´       s%| j7                  ||´       | j9                  ||´       yyy)z\Extract the TarInfo object tarinfo to a physical
           file called targetpath.
        rW  r-   z -> N)r‹  rﬂ   r¢   r[  r/   rd  rD  ⁄makedirsr`  rb  r™  r™   rc  r_  ⁄makefilera  ⁄makedirr/  ⁄makefifor*  r,  ⁄makedev⁄makelinkrt  rÓ  ⁄makeunknownr≈  r«  r∆  )r©   r>  ⁄
targetpathræ  rª  ⁄	upperdirss         rD   r”  zTarFile._extract_memberx	  sé  Ä   ◊&—&†s”+à
ÿ◊'—'®¨RØV©V”4à
Ù óGëGóOëO†J”/à	ŸúRüWôWü^ô^®I‘6Ù èKâKò	‘"‡è=â=å?ògümômúoÿèIâIêa†wß|£|∞W◊5E“5E–F’G‡èIâIêaòüô‘&‡è=â=å?ÿèMâMò'†:’.ÿè]â]å_ÿèLâLò†*’-ÿè^â^‘ÿèMâMò'†:’.ÿè]â]å_†ß°§ÿèLâLò†*’-ÿè]â]å_†ß°§ÿèMâMò'†:’.ÿè\â\§—0ÿ◊—òW†j’1‡èMâMò'†:‘.·ÿèJâJêw†
®M‘:ÿó=ë=î?ÿó
ë
ò7†J‘/ÿó
ë
ò7†J’/ # rF   c                 Û‘   ó 	 |j                   Ät        j                  |´       yt        j                  |d´       y# t        $ r# t        j                  j                  |´      sÇ Y yw xY w)z,Make a directory called targetpath.
        Ni¿  )r´   r¢   ⁄mkdir⁄FileExistsErrorr/   ra  ©r©   r>  rÊ  s      rD   r·  zTarFile.makedir©	  sT   Ä 
	ÿè|â|–#‰óëò’$Ù óëò†U’+¯‹Ú 	‹ó7ë7ó=ë=†‘,ÿÒ -	˙s   Ç!; §; ª)A'¡&A'c           	      Û∆  ó | j                   }|j                  |j                  ´       | j                  }t	        |d´      5 }|j
                  Åd|j
                  D ])  \  }}|j                  |´       t        |||t        |´       å+ |j                  |j                  ´       |j                  ´        nt        |||j                  t        |´       ddd´       y# 1 sw Y   yxY w)z'Make a file called targetpath.
        r=  N)
r≈   r˛   r:  rK  rE  r;  rr   r   r1   ⁄truncate)r©   r>  rÊ  ⁄sourcery   ⁄targetr  r1   s           rD   r‡  zTarFile.makefile∏	  s™   Ä  óëàÿèâêG◊'—'‘(ÿ◊"—"à‹êz†4‘(®Fÿè~â~–)ÿ$+ßN§NëLêFòDÿóKëK†‘'‹†®∞¥i¿’I %3 óëòGüLôL‘)ÿóë’!‰òF†F®GØL©Lº)¿W‘M˜ )◊(—(˙s   ¡ BC√C c                 Ûf   ó | j                  ||´       | j                  dd|j                  z  ´       y)zYMake a file from a TarInfo object with an unknown type
           at targetpath.
        r-   z9tarfile: Unknown file type %r, extracted as regular file.N)r‡  r™  rt  rÎ  s      rD   rÂ  zTarFile.makeunknown»	  s3   Ä  	èâêgòz‘*ÿè	â	ê! 2ÿ4;∑L±LÒAı 	BrF   c                 Ûd   ó t        t        d´      rt        j                  |´       yt        d´      Ç)z'Make a fifo called targetpath.
        ⁄mkfifozfifo not supported by systemN)rß   r¢   rÚ  r   rÎ  s      rD   r‚  zTarFile.makefifo–	  s&   Ä Ù î2êx‘ ‹èIâIêj’!‰–=”>–>rF   c                 Ûf  ó t        t        d´      rt        t        d´      st        d´      Ç|j                  }|Äd}|j	                  ´       r|t
        j                  z  }n|t
        j                  z  }t        j                  ||t        j                  |j                  |j                  ´      ´       y)z<Make a character or block device called targetpath.
        ⁄mknodr„  z'special devices not supported by systemNrY  )rß   r¢   r   r´   r,  rÜ  ⁄S_IFBLK⁄S_IFCHRrÙ  r„  ru  rv  )r©   r>  rÊ  r´   s       rD   r„  zTarFile.makedevÿ	  sÜ   Ä Ù îrò7‘#¨7¥2∞y‘+A‹–H”I–I‡è|â|àÿà<‡àDÿè=â=å?ÿîDóLëL— âD‡îDóLëL— àD‰
èâêòT‹óëòG◊,—,®g◊.>—.>”?ı	ArF   c                 Û:  ó 	 |j                  ´       rUt        j                  j                  |´      rt        j                  |´       t        j
                  |j                  |´       yt        j                  j                  |j                  ´      r!t        j                  |j                  |´       y| j                  | j                  |´      |´       y# t        $ r> 	 | j                  | j                  |´      |´       Y y# t        $ r t        d´      dÇw xY ww xY w)zµMake a (symbolic) link called targetpath. If it cannot be created
          (platform limitation), we try to make a copy of the referenced file
          instead of a link.
        z%unable to resolve link inside archiveN)rb  r¢   r/   ⁄lexists⁄unlink⁄symlinkrc  rD  ry  ⁄linkr”  r›  ⁄symlink_exceptionrx  r   rÎ  s      rD   r‰  zTarFile.makelinkÍ	  sﬁ   Ä 
	V‡è}â}å‹ó7ë7ó?ë?†:‘.‰óIëIòj‘)‹ó
ë
ò7◊+—+®Z’8‰ó7ë7ó>ë>†'◊"6—"6‘7‹óGëGòG◊0—0∞*’=‡◊(—(®◊)?—)?¿”)Hÿ)3ı5¯‰ Ú 	VVÿ◊$—$†T◊%;—%;∏G”%Dÿ%/ˆ1¯‰Ú V‹"–#J”K–QU–UV˙		V˙s+   ÇA$C ¡'A	C ¬1!C √	D√!D ƒ DƒDc                 ÛÑ  ó t        t        d´      rıt        j                  ´       dk(  r›|j                  }|j                  }|sj	 t
        r.|j                  r"t        j                  |j                  ´      d   }	 t        r.|j                  r"t        j                  |j                  ´      d   }|Äd}|Äd}	 |j                  ´       r(t        t        d´      rt        j                  |||´       yt        j                  |||´       yyy# t        $ r Y åõw xY w# t        $ r Y åuw xY w# t        $ r}t!        d´      |Çd}~ww xY w)zSet owner of targetpath according to tarinfo. If numeric_owner
           is True, use .gid/.uid instead of .gname/.uname. If numeric_owner
           is False, fall back to .gid/.uid when the search based on name
           fails.
        ⁄geteuidr   r.   NrH   ⁄lchownzcould not change owner)rß   r¢   r˛  r4   r3   rö  r6   ⁄getgrnamrx  rò  r5   ⁄getpwnamrb  rˇ  r≈  r“   r   )r©   r>  rÊ  rª  ⁄g⁄ur  s          rD   r≈  zTarFile.chown
  s  Ä Ù î2êy‘!§bßj°j£l∞a“&7‡óëàAÿóëàAŸ ›òwü}ö}‹üLôL®Ø©”7∏—:ò›òwü}ö}‹üLôL®Ø©”7∏—:ò àyÿêÿàyÿêDÿó=ë=î?§w¨r∞8‘'<‹óIëIòj®!®Q’/‰óHëHòZ®®A’./ '8–!¯Ù  Ú Ÿ˚Ù
  Ú Ÿ˚Ù Ú D‹"–#;”<¿!–C˚D˙sB   ¡4D ¡84D ¬57D% √-D% ƒ	DƒDƒ	D"ƒ!D"ƒ%	D?ƒ.D:ƒ:D?c                 Ûö   ó |j                   Äy	 t        j                  ||j                   ´       y# t        $ r}t	        d´      |Çd}~ww xY w)zASet file permissions of targetpath according to tarinfo.
        Nzcould not change mode)r´   r¢   r«  r“   r   )r©   r>  rÊ  r  s       rD   r«  zTarFile.chmod$
  sF   Ä  è<â<–ÿ	?‹èHâHêZ†ß°’.¯‹Ú 	?‹–6”7∏Q–>˚	?˙s   è 0 ∞	A
πA¡A
c                 Û∞   ó |j                   }|Äyt        t        d´      sy	 t        j                  |||f´       y# t        $ r}t        d´      |Çd}~ww xY w)zBSet modification time of targetpath according to tarinfo.
        Nr∆  z"could not change modification time)r2   rß   r¢   r∆  r“   r   )r©   r>  rÊ  r2   r  s        rD   r∆  zTarFile.utime.
  sZ   Ä  óëàÿà